<!DOCTYPE html>
<html>

<head>
    <title>Tutorial 5 - Explicit Encoding</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        body {
            display: flex;
            justify-content: space-between;
        }

        .hidden {
            display: none !important;
        }

        .sidebar {
            top: 170.67px;
            position: sticky;
            width: 20px;
            height: 900px;
            background-color: #BEBEBE;
            border: 1px solid grey;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        .sidebar:hover {
            background-color: #cfcfcf;
        }

        .sidebarContent {
            top: 170.67px;
            position: sticky;
            width: 500px;
            height: 875px;
            padding: 10px;
            overflow-y: scroll;
            display: flex;
            flex-direction: column;
            font-size: 20px;
        }

        .sidebarContent img {
            margin: 20px;
        }
    </style>
    <script>
        pinoLog("info", "Beginning tutorial 5");
        let paused = false;

        let data1 = [];
        data1.length = 40;
        let data2 = [];
        data2.length = 40;

        let backgroundImg = null;
        let backgroundWidth = 0;
        let backgroundHeight = 0;
        let images1 = [];
        let images2 = [];

        let drawIndex = 0;

        const CANVAS_WIDTH = 1200;
        const CANVAS_HEIGHT = 900;
        function preload() {
            backgroundImg = loadImage(`./blob-images/site.png`);
            for (let i = 0; i <= 310; i++) {
                images1.push(loadImage(`./blob-images/blobs-1-frame-${i}.png`));
            }
            for (let j = 0; j <= 300; j++) {
                images2.push(loadImage(`./blob-images/blobs-2-frame-${j}.png`));
            }
        }

        function setup() {
            let data1Promise = fetch("./blob-points-1.csv")
                .then(response => response.text())
                .then(txt => Papa.parse(txt))
                .then(parsed => {
                    parsed.data.forEach(point => {
                        try {
                            const index = parseInt(point[0]);
                            if (!isNaN(index)) {
                                if (data1[index]) data1[index].push([point[1], point[2], point[3]])
                                else data1[index] = [];
                            }
                        } catch (err) { }
                    });
                })
                .catch(err => console.error(err));
            let data2Promise = fetch("./blob-points-2.csv")
                .then(response => response.text())
                .then(txt => Papa.parse(txt))
                .then(parsed => {
                    parsed.data.forEach(point => {
                        try {
                            const index = parseInt(point[0]);
                            if (!isNaN(index)) {
                                if (data2[index]) data2[index].push([point[1], point[2], point[3]])
                                else data2[index] = [];
                            }
                        } catch (err) { }
                    });
                })
                .catch(err => console.error(err));
            Promise.all([data1Promise, data2Promise])
                .then(() => {
                    if (data1.length < data2.length) {
                        let saved = [...data1];
                        data1 = data2;
                        data2 = saved;
                    }
                    pinoLog("trace", "Loaded in observed & predicted blob data points");
                })
                .catch(err => pinoLog("error", "Error loading in observed & predicted blob data points"));
            createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);

            toggleTutorials();
            setupEventListeners();

            const aspectRatio = backgroundImg.width / backgroundImg.height;
            backgroundWidth = 250 * aspectRatio;
            backgroundHeight = 250;
        }

        function draw() {
            if (!data1[0] || !data2[0]) return;
            if (!paused) drawIndex += 0.5;
            if (drawIndex > 309) drawIndex = 0;

            clear();

            drawDisplay("Predicted", (backgroundWidth + 20) * 0 + 20 * 1, (backgroundHeight + 20) * 0 + 20 * 1, true, false, false, false);
            drawDisplay("Observed", (backgroundWidth + 20) * 1 + 20 * 2, (backgroundHeight + 20) * 0 + 20 * 1, false, true, false, false);
            drawDisplay("Predicted + Observed", (backgroundWidth + 20) * 2 + 20 * 3, (backgroundHeight + 20) * 0 + 20 * 1, true, true, false, false);

            drawDisplay("Outlines", (backgroundWidth + 20) * 0 + 20 * 1, (backgroundHeight + 20) * 1 + 20 * 2, false, false, true, false);
            drawDisplay("Original Image", (backgroundWidth + 20) * 1 + 20 * 2, (backgroundHeight + 20) * 1 + 20 * 2, false, false, false, false);
            drawDisplay("Outlines + Predicted + Observed", (backgroundWidth + 20) * 2 + 20 * 3, (backgroundHeight + 20) * 1 + 20 * 2, true, true, true, false);

            drawDisplay("Difference Lines (DL)", (backgroundWidth + 20) * 0 + 20 * 1, (backgroundHeight + 20) * 2 + 20 * 3, false, false, false, true);
            drawDisplay("DL + Outlines", (backgroundWidth + 20) * 1 + 20 * 2, (backgroundHeight + 20) * 2 + 20 * 3, false, false, true, true);
            drawDisplay("DL + Outlines + Predicted + Observed", (backgroundWidth + 20) * 2 + 20 * 3, (backgroundHeight + 20) * 2 + 20 * 3, true, true, true, true);

            drawColourKey();
        }

        function findMiddle(index1, index2) {
            let smallestX = 10000000;
            let largestX = 0;
            let smallestY = 10000000;
            let largestY = 0;
            for (let i = 0; i <= 40; i++) {
                let data1X = +data1[i][index1][1];
                let data1Y = +data1[i][index1][2];
                let data2X = +data2[i][index2][1];
                let data2Y = +data2[i][index2][2];

                if (data1X < smallestX) smallestX = data1X;
                if (data2X < smallestX) smallestX = data2X;
                if (data1X > largestX) largestX = data1X;
                if (data2X > largestX) largestX = data2X;

                if (data1Y < smallestY) smallestY = data1Y;
                if (data2Y < smallestY) smallestY = data2Y;
                if (data1Y > largestY) largestY = data1Y;
                if (data2Y > largestY) largestY = data2Y;
            }
            return [(largestX + smallestX) / 2, (largestY + smallestY) / 2]
        }

        function distance(x1, x2, y1, y2) {
            return Math.sqrt(Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2));
        }

        /**
         * Draw a display for the explicit encoding blob example.
         */
        function drawDisplay(label, left, top, predicted, observed, outlines, lines) {
            colorMode(RGB, 255);
            noStroke();
            fill(190, 190, 190);
            rect(left - 10, top - 10, backgroundWidth + 20, backgroundHeight + 20, 10);

            const diffStep = data2[0].length / data1[0].length;
            let index1 = Math.floor(drawIndex);
            let index2 = Math.floor(drawIndex * diffStep);
            tint(255);
            const scaleRatio = backgroundWidth / backgroundImg.width;
            image(backgroundImg, left, top, backgroundWidth, backgroundHeight);
            if (observed) {
                tint(255, 126);
                image(images1[index1], left, top, backgroundWidth, backgroundHeight);
            }
            if (predicted) {
                tint(255, 126);
                image(images2[index2], left, top, backgroundWidth, backgroundHeight);
            }
            colorMode(RGB, 255, 255, 255, 1);
            strokeWeight(5);
            const pointOffsetX = 167;
            const pointOffsetY = 125;
            if (lines) {
                let middle = findMiddle(index1, index2);
                let middleX = middle[0];
                let middleY = middle[1];

                for (let k = 0; k <= 40; k++) {
                    let x1 = +data1[k][index1][1];
                    let y1 = +data1[k][index1][2];
                    let x2 = +data2[k][index2][1];
                    let y2 = +data2[k][index2][2];
                    if (distance(middleX, x1, middleY, y1) > distance(middleX, x2, middleY, y2)) {
                        stroke(255, 0, 0, 0.5);
                    } else {
                        stroke(48, 213, 200, 0.5);
                    }
                    line(
                        x1 * scaleRatio + left + pointOffsetX,
                        y1 * scaleRatio + top + pointOffsetY,
                        x2 * scaleRatio + left + pointOffsetX,
                        y2 * scaleRatio + top + pointOffsetY
                    );
                }
            }
            if (outlines) {
                stroke(255, 165, 0, 1);
                for (let i = 0; i <= 40; i++) {
                    let x = +data1[i][index1][1];
                    let y = +data1[i][index1][2];
                    point(
                        x * scaleRatio + left + pointOffsetX,
                        y * scaleRatio + top + pointOffsetY
                    );
                }

                stroke(0, 255, 0, 1);
                for (let j = 0; j <= 40; j++) {
                    let x = +data2[j][index2][1];
                    let y = +data2[j][index2][2];
                    point(
                        x * scaleRatio + left + pointOffsetX,
                        y * scaleRatio + top + pointOffsetY
                    );
                }
            }

            if (observed || predicted || outlines || lines) {
                stroke(34, 154, 34);
                line(left, top + backgroundHeight, left + backgroundWidth * (drawIndex / 309), top + backgroundHeight);
            }

            strokeWeight(2);
            stroke(0, 0, 0);
            fill(255, 255, 255);
            textSize(18);
            text(label, left + 10, top + 18);
        }

        function drawColourKey () {
            colorMode(RGB, 255);
            noStroke();
            let left = 10;
            fill(0, 0, 0)
            text("Colour Key: ", left, CANVAS_HEIGHT - 15);
            left += textWidth("Colour Key: ") + 10;
            /* Predicted */
            const predicted = "Predicted";
            fill(0, 0, 204);
            circle(left, CANVAS_HEIGHT - 20, 10);
            left += 10;
            text(predicted, left, CANVAS_HEIGHT - 15);
            left += textWidth(predicted) + 10;
            /* Observed */
            fill(253, 218, 13);
            const observed = "Observed";
            circle(left, CANVAS_HEIGHT - 20, 10);
            left += 10;
            text(observed, left, CANVAS_HEIGHT - 15);
            left += textWidth(observed) + 10;
            /* Predicted outline */
            fill(0, 255, 0);
            const predictedOutline = "Predicted Outline";
            circle(left, CANVAS_HEIGHT - 20, 10);
            left += 10;
            text(predictedOutline, left, CANVAS_HEIGHT - 15);
            left += textWidth(predictedOutline) + 10;
            /* Observed outline */
            fill(255, 165, 0);
            const observedOutline = "Observed Outline";
            circle(left, CANVAS_HEIGHT - 20, 10);
            left += 10;
            text(observedOutline, left, CANVAS_HEIGHT - 15);
            left += textWidth(observedOutline) + 10;
            /* Predicted difference lines*/
            fill(48, 213, 200);
            const predictedDL = "Predicted Difference Lines";
            circle(left, CANVAS_HEIGHT - 20, 10);
            left += 10;
            text(predictedDL, left, CANVAS_HEIGHT - 15);
            left += textWidth(predictedDL) + 10;
            /* Observed difference lines */
            fill(255, 0, 0);
            const observedDL = "Observed Difference Lines";
            circle(left, CANVAS_HEIGHT - 20, 10);
            left += 10;
            text(observedDL, left, CANVAS_HEIGHT - 15);
            left += textWidth(observedDL) + 10;
        }

        function keyPressed(event) {
            if (event.keyCode === 32) {
                paused = !paused;
                pinoLog("trace", `Toggled pause ${paused ? "on" : "off"}`);
            }
            if (event.keyCode === LEFT_ARROW) {
                drawIndex -= 20;
                pinoLog("trace", "Rewinding videos")
            }
            if (event.keyCode === RIGHT_ARROW) {
                drawIndex += 20;
                pinoLog("trace", "Fast-forwarding videos");
            }
            if (drawIndex < 0) drawIndex = 0;
            if (drawIndex > 309) drawIndex = 309;
        }

        function setupEventListeners() {
            document.getElementById("tutorialSidebar")?.addEventListener("click", e => toggleTutorials());
        }

        function toggleTutorials() {
            const tutorialSidebar = document.getElementById("tutorialSidebar");
            const tutorialContent = document.getElementById("tutorialContent");
            if (tutorialContent?.classList.contains("hidden") === false) {
                tutorialContent.classList.add("hidden");
                tutorialSidebar.innerHTML = "<";
                pinoLog("trace", "Closed tutorials tab");
            } else if (tutorialContent?.classList.contains("hidden")) {
                tutorialContent.classList.remove("hidden");
                tutorialSidebar.innerHTML = ">";
                pinoLog("trace", "Opened tutorials tab");
            }
        }

        function pinoLog(type, message) {
            // fetch("http://localhost:3019/log", {
            fetch("http://hci-sandbox.usask.ca:3019/log", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ type: type, msg: message }),
            }).then(response => {
                if (response.status !== 200) console.error("Logging error: ", response.text());
            }).catch(err => console.error(err));
        }
    </script>
</head>

<body>
    <main></main>
    <div style="display: flex;">
        <div id="tutorialSidebar" class="sidebar">&#60;</div>
        <div id="tutorialContent" class="sidebarContent hidden">
            <h1>Tutorial 5 - Explicit Encoding</h1>
            <p>
                For the final task, imagine that you are a microbiologist working for Environment Canada. You have been
                researching the effectiveness of hydrocarbon-eating bacteria in cleaning up oil spills, and now that
                youâ€™ve tested these bacteria, you need to see how well they did against the predicted models.
            </p>
            <p>
                To the left you will see nine side-by-side displays that you can use to compare the effectiveness of the
                bacteria. Each display is running on a constant loop. A video progress bar is drawn under each display
                to indicate the position in the video. Press spacebar to pause/play. Use the left and right arrow keys
                to rewind/fast-forward.
            </p>
            <img src="../tutorials/img/tutorial-task-5-1.png" />
            <strong>
                Displays are labeled. But for convenience, they will be described as displays 1 through 9 as in the
                figure above. The middle image (display 5) is the original area of effect.
            </strong>
            <p>
                Display 1 represents the predicted simulation of the effectiveness of the hydrocarbon-eating bacteria.
                The blue blob represents the predicted scope of the oil spill over time. Display 2 represents the
                observational data collected during an actual oil spill. The yellow
                blob represents the true scope of the spill being reduced over time by the bacteria.
            </p>
            <img src="../tutorials/img/tutorial-task-5-2.png" />
            <p>
                Using these two videos to compare:
            </p>
            <ul>
                <li>Are the bacteria working as effectively as the simulation predicted?</li>
                <li>Do the bacteria under/over-perform? If so, when, and where does this occur?</li>
            </ul>
            <p>
                Display 3 combines both the predicted and the observed oil spill data into a single video.
            </p>
            <img src="../tutorials/img/tutorial-task-5-3.png" />
            <p>
                Using this video to compare:
            </p>
            <ul>
                <li>Are the bacteria working as effectively as the simulation predicted? Has your answer changed?</li>
                <li>Do you prefer this combined video over the separate videos? Why or why not?</li>
            </ul>
            <p>
                Display 4 introduces another representation of the oil spill over time. Dotted outlines are placed
                around the perimeter of the predicted and observed data to replace the blobs. Display 6 combines the
                outline representation with the spill blobs.
            </p>
            <img src="../tutorials/img/tutorial-task-5-4.png" />
            <p>
                Using these two videos to compare:
            </p>
            <ul>
                <li>Are the bacteria working as effectively as the simulation predicted? Has your answer changed?</li>
                <li>Which display do you prefer and why?</li>
                <li>Does the outline technique make it easier to compare than the blobs? Why or why not?</li>
            </ul>
            <p>
                Finally, display 7 introduces a representation of the difference between the predicted and observed oil
                spill data called difference lines (DL). You will notice that the line colours change as the video
                plays. The lines are coloured blue where the predicted blob is larger, and they are coloured red where
                the observed blob is larger.
            </p>
            <p>
                Display 8 combines this technique with perimeter outlines, and display 9 combines all techniques (i.e.,
                observed & predicted blobs, perimeter outlines, and difference lines) into one video.
            </p>
            <img src="../tutorials/img/tutorial-task-5-5.png" />
            <p>
                Using these three videos to compare:
            </p>
            <ul>
                <li>Are the bacteria working as effectively as the simulation predicted? Has your answer changed?</li>
                <li>Which display do you prefer and why?</li>
                <li>Do the difference lines make it easier to compare than the other techniques? Why or why not?</li>
            </ul>
        </div>
    </div>
</body>

</html>